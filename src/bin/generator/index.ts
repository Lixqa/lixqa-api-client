/**
 * Main API client generator
 * Orchestrates the generation of TypeScript API client code from API schema
 */

import fs from 'fs';
import path from 'path';
import prettier from 'prettier';
import packageJson from '../../../package.json' with { type: 'json' };

import { createLogger, type Logger } from './logger.js';
import { fetchApiSchema, type Route } from './fetch-schema.js';
import { processRoutes, buildCompleteTree } from './tree-builder.js';
import {
  generateFromTree,
  generateInterfaceFromTree,
  collectTypesFromTree,
} from './code-generator.js';

/**
 * Generator options
 */
export interface GeneratorOptions {
  url: string;
  output: string;
  debug?: boolean;
  separateTypes?: boolean;
  format?: boolean;
}

/**
 * Generates the complete TypeScript API client code
 * @param options - Generator options
 */
export async function generateClient(options: GeneratorOptions): Promise<void> {
  const API_BASE = options.url;
  const OUTPUT = options.output;
  const DEBUG = options.debug ?? false;
  const SEPARATE_TYPES = options.separateTypes || false;

  const log = createLogger(DEBUG);

  // Fetch API schema
  let routes: Route[];
  try {
    routes = await fetchApiSchema(API_BASE, log);
  } catch (error) {
    process.exit(1);
  }

  // Process routes to extract methods
  const {
    routes: processedRoutes,
    totalGeneratedRoutes,
    totalGeneratedMethods,
  } = processRoutes(routes, log);

  // Build route tree
  log.debug('Building route tree...');
  const tree = buildCompleteTree(processedRoutes);

  // Collect types if separate-types is enabled
  let typeDefinitions = new Map<string, { name: string; type: string }>();
  if (SEPARATE_TYPES) {
    log.debug('Collecting type definitions...');
    typeDefinitions = collectTypesFromTree(tree, [], typeDefinitions, log);
  }

  // Generate API implementation
  log.debug('Generating API implementation...');
  let apiImpl = 'return {\n';
  apiImpl += generateFromTree(tree, '  ', [], SEPARATE_TYPES, log);
  apiImpl += '};';

  // Generate TypeScript interface
  log.debug('Generating TypeScript interface...');
  let apiInterface = 'interface ApiMethods {\n  [key: string]: any;\n';
  const interfaceSig = generateInterfaceFromTree(
    tree,
    '  ',
    [],
    SEPARATE_TYPES,
    log,
  );
  if (interfaceSig) {
    apiInterface += '  ' + interfaceSig.split('; ').join(';\n  ') + ';\n';
  }
  apiInterface += '}\n';

  // Generate type definitions
  let typeDefsCode = '';
  if (SEPARATE_TYPES && typeDefinitions.size > 0) {
    log.debug(
      `Generating ${typeDefinitions.size} separate type definitions...`,
    );
    typeDefinitions.forEach(({ name, type }) => {
      typeDefsCode += `export type ${name} = ${type};\n`;
    });
    typeDefsCode += '\n';
  }

  // Assemble final generated code
  const generatedCode = `/**
 * Auto-generated API client
 * Generated at: ${new Date().toISOString()}
 * Base URL: ${API_BASE}
 * 
 * DO NOT EDIT THIS FILE MANUALLY
 */

import { createRequest, createClient as createBaseClient } from '${packageJson.name}';

${typeDefsCode}${apiInterface}

const request = createRequest();

const generateApiObject = (requestFn: ReturnType<typeof createRequest>): ApiMethods => {
  ${apiImpl}
};

export const createClient = createBaseClient(generateApiObject);

export const api: ApiMethods = generateApiObject(request);
`;

  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT);
  if (!fs.existsSync(outputDir)) {
    log.debug(`Creating output directory: ${outputDir}`);
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Display generation summary
  log.info('\nðŸ“Š Generation Summary:');
  log.info(`   Routes: ${totalGeneratedRoutes}`);
  log.info(`   Methods: ${totalGeneratedMethods}`);
  log.info(`   Output: ${OUTPUT}\n`);

  // Write output file
  if (options.format !== false) {
    try {
      log.debug('Formatting code with Prettier...');
      const formatted = await prettier.format(generatedCode, {
        parser: 'typescript',
        semi: true,
        singleQuote: true,
        trailingComma: 'es5',
        printWidth: 120,
        tabWidth: 2,
      });
      fs.writeFileSync(OUTPUT, formatted);
      log.success('API client generated and formatted successfully!');
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      log.warning(`Formatting failed: ${errorMessage}`);
      log.debug('Writing unformatted code...');
      fs.writeFileSync(OUTPUT, generatedCode);
      log.success('API client generated (unformatted)');
    }
  } else {
    log.debug('Skipping formatting...');
    fs.writeFileSync(OUTPUT, generatedCode);
    log.success('API client generated successfully!');
  }
}

